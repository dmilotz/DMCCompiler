/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Language.jj */
/*@egen*/options{
    IGNORE_CASE=false;
                                               
                                                            
               
                 
    DEBUG_PARSER=false;
}

PARSER_BEGIN(Language)
package wci.frontend;

import java.util.ArrayList;
import java.util.HashSet;
import java.io.*;

import wci.intermediate.*;
import wci.backend.*;
import wci.util.*;

import wci.intermediate.symtabimpl.*;
import wci.intermediate.typeimpl.*;
import wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import wci.intermediate.symtabimpl.DefinitionImpl.*;

import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class Language/*@bgen(jjtree)*/implements LanguageTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTLanguageState jjtree = new JJTLanguageState();

/*@egen*/
    private static final String SOURCE_SUFFIX = ".pcl";
    private static final String OUTPUT_SUFFIX = ".j";

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    public static void main(String[] args)
        throws Exception
    {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

        // Process the source file path which ends in .pcl
        // and create the output file path which ends in .j
        String sourceFilePath = args[0];
        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();
        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);
        String objectFilePath = (suffixIndex == truncatedLength)
            ? sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX
            : sourceFilePath + OUTPUT_SUFFIX;

        // Parse a Pcl program.
        Reader    reader = new FileReader(sourceFilePath);
        Language parser = new Language(reader);
        SimpleNode rootNode = parser.Program();
		
        // Print the cross-reference table.
        CrossReferencer crossReferencer = new CrossReferencer();
        crossReferencer.print(symTabStack);
        	

        // Visit the parse tree nodes to decorate them with type information.
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);

		// Create the compiler backend and generate code.
        Backend backend = BackendFactory.createBackend("compile");
        backend.process(iCode, symTabStack, objectFilePath);
		
			
    }
}
PARSER_END(Language)


/*****************************************************************************

	Language Tokens

******************************************************************************/

SKIP : {
   <IGNORE : [" ", "\t", "\n", "\r"]> |
   <IGNORE2: <SINGLE_LINE_COMMENT> >
}

/**
 *	Private Helper Tokens
 */ 
TOKEN: {
	
	<#LETTER: ["a"-"z","A"-"Z"]> | 
	<#DIGIT: ["0"-"9"]> |
	<#WORD: <LETTER> (<LETTER> | <DIGIT>)* >
}	



/**
 *	URL & Domain Tokens
 *
 *	A url must begin with a letter or digit and the domain name cannot 
 *	have two consecutive dots or hyphens at a time between letters or digits. 
 *	After domain name a forward slash separates sub sections
 */
 
TOKEN : {

	// Consider spliting parts of URL into their own private tokens (e.g., PREFIX, DOMAIN, SUFFIX)
	<URL : <QUOTATION_MARK> "http" (["s"])? "://" ( (<WORD> | <DIGIT>)+ (<DOT> | <MINUS>)? )+ "." <WORD> ("/" (<WORD> | <DIGIT> | ["-", "_", ".", "&", "?", "="])* )* <QUOTATION_MARK>  >
	|
	
	<DOMAIN:((<WORD> | <DIGIT>)+ ([".","-"])?)+ "." (<WORD>)+> |
	
	<BOOLEAN: "True" | "False">
}


/**
 *	Character and String Tokens
 */

TOKEN : {

	<SINGLE_LINE_COMMENT: "--" (~["\n", "\r"])* > | 
	
	<STRING : ["\""] (~["\"", "\n", "\r"])* ["\""] >

}


/**
 *	Number Tokens
 */

TOKEN:
{
	<INTEGER: <DIGIT> (<DIGIT>)*> |
	
	<REAL: (<DIGIT>)* "." (<DIGIT>)+ >
	
}
 
 
/**
 *	Reserved Word Tokens
 */
 
TOKEN : {
	
	<FOREACH : "foreach"> |
	
	<IN : "in"> |
	
	<ELSE : "else"> |
	
	<ELSEIF : "elseif"> |
	
	<IF : "if"> |
	
	<FOR : "for" >|

	< FUNCTION: "function" >|
	< VOID: "void" >|
	< RETURN: "return" >|
	< DISPLAY: "display" >
	
}


/**
 *	Data Types
 * 		Data types must begin with a capital letter
 */
TOKEN : {

	<BOOLEAN_TYPE : "Boolean"> |

	<DOMAIN_TYPE : "Domain"> |
	
	<INTEGER_TYPE : "Integer"> |
	
	<INTEGER_LIST_TYPE :"List[Integer]" > |
		<REAL_LIST_TYPE :"List[Real]" > |
			<STRING_LIST_TYPE :"List[String]" > |
	<REAL_TYPE : "Real"> |
	
	<STRING_TYPE : "String"> |
	
	<URL_TYPE : "Url">
	
}


/**
 *	Special Symbol Tokens
 */

TOKEN : {
	<LESS_EQUALS : "<="> |
	
	<GREATER_EQUALS : ">="> |
	
	<PLUS_EQUALS : "+="> |
	
	<MINUS_EQUALS : "-="> |
	
	<STAR_EQUALS : "*="> |
	
	<EQUALS : "=="> |
	
	<MODULUS_EQUALS : "%="> |
	
	<NOT_EQUALS : "<>"> |
	
	<MODULUS : "%"> |
	
	<STAR : "*"> |
	
	<DIVIDE : "/"> |
	
	<MINUS : "-"> |
	
	<PLUS : "+"> |
	
	<ASSIGNMENT : "="> |
	
	<SEMICOLON : ";"> |
	
	<LESS_THAN : "<"> |
	
	<GREATER_THAN : ">"> |
	
	<QUOTATION_MARK : "\""> |
	
	<LEFT_PAREN : "("> |
	
	<RIGHT_PAREN : ")"> |
	
	<LEFT_BRACE : "{"> |
	
	<RIGHT_BRACE : "}"> |
	
	<DOT : "."> |
	
	<DOLLAR_SIGN : "$"> |
	< COLON : ":" >|
	<COMMA : ",">|
	< OPBR : "[" >|
	< CLBR : "]" >

}	


/**
 *	Identifier
 */
TOKEN : {

	<IDENTIFIER: <LETTER> ("_" | <LETTER> | <DIGIT>)* >
}

TOKEN: { /*	Error token */
    <ERROR : ~["\r", "\n"]> |
    <EOL     : ["\r", "\n"]>
}

/*****************************************************************************

	Language Productions

******************************************************************************/

/* Based on PLC */
SimpleNode Program()          : {/*@bgen(jjtree) Program */
        ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
  	SimpleNode rootNode;
	programId = symTabStack.enterLocal("");
    programId.setDefinition(DefinitionImpl.PROGRAM);
    programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
    symTabStack.setProgramId(programId);
}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/

	
  
	/* Try parsing statements */
    try {
        rootNode = StatementList()  {
            return rootNode;
        }
    }
    catch (ParseException ex) {
        HashSet syncSet = new HashSet();
        syncSet.add(EOF);
        
        handleError(ex, syncSet, true);
        return null;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* 
   Based on PLC -  
	Removed error checking code.
	Removed #void.
*/
SimpleNode StatementList () : {/*@bgen(jjtree) StatementList */
        ASTStatementList jjtn000 = new ASTStatementList(JJTSTATEMENTLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	HashSet syncSet = new HashSet();
    syncSet.add(SEMICOLON);
    syncSet.add(EOF);
}
{/*@bgen(jjtree) StatementList */
        try {
/*@egen*/
	(  Statement(syncSet)  )*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	//(BlockStatement() | Statement() )*
	
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



/* 
	Based on PLC - 
		Removed Assignment, MethodCall
*/
void Statement(HashSet syncSet)       : {}
{
    try {     BlockStatement() | Function()|
         VariableDeclaration(0)
      |  AssignmentStatement() | FuncCall()|display()
      
      |  Error() { throw new ParseException(); }
    }
    catch (ParseException ex) {
         handleError(ex, syncSet, false);
    }
	
	<SEMICOLON>
}

void BlockStatement ()       : {Token t;}
{ 
	IfStatement() | ForStatement()
}

/* mks */
Token VariableDeclaration(int x)          : {/*@bgen(jjtree) TypeSpec */
                                             ASTTypeSpec jjtn000 = new ASTTypeSpec(JJTTYPESPEC);
                                             boolean jjtc000 = true;
                                             jjtree.openNodeScope(jjtn000);
/*@egen*/ArrayList<SymTabEntry> variableList;
	                                 int index = 0;}
{/*@bgen(jjtree) TypeSpec */
        try {
/*@egen*/
	TypeSpecification()
	{
		Token typeSpecToken = token;
   		
	}

	<DOLLAR_SIGN> <IDENTIFIER>
	{
	  		variableList = new ArrayList<SymTabEntry>();
            processVariableDecl(token, index++, variableList);
			
			SymTabEntry typeId = symTabStack.lookup(typeSpecToken.image);
            typeId.appendLineNumber(typeSpecToken.beginLine);
            TypeSpec type = typeId.getTypeSpec();
			jjtn000.setTypeSpec(type);
			if(x==1)
			jjtn000.setAttribute(ID, token.image);
            for (SymTabEntry variableId : variableList) {
              if(x ==1)
                variableId.setTypeSpec(Predefined.funcParamType);
                else
                variableId.setTypeSpec(type);
            }
            return typeSpecToken;
	}/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

		 

	{
        programId.setAttribute(ROUTINE_LOCALS_COUNT, index);
    }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
    
}

void display()         :{/*@bgen(jjtree) display */
  ASTdisplay jjtn000 = new ASTdisplay(JJTDISPLAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) display */
  try {
/*@egen*/
  < DISPLAY ><LEFT_PAREN >Factor()< RIGHT_PAREN >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
  
void ForStatement()      : {/*@bgen(jjtree) For */
                            ASTFor jjtn000 = new ASTFor(JJTFOR);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) For */
        try {
/*@egen*/
	<FOR> 
		<LEFT_PAREN> 
		AssignmentStatement()<SEMICOLON>
		 BooleanExpression()  <SEMICOLON> 
		AssignmentStatement()  
		<RIGHT_PAREN>
		<LEFT_BRACE> 
		StatementList() 
		<RIGHT_BRACE>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
		 
}

void IfStatement ()     : {/*@bgen(jjtree) IF */
                           ASTIF jjtn000 = new ASTIF(JJTIF);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) IF */
        try {
/*@egen*/
	<IF>
		( IfBlockStructure() ) //#IF(1)
	
	( 
	
	(<ELSEIF>/*@bgen(jjtree) #ELSEIF( 2) */
                  {
                    ASTELSEIF jjtn001 = new ASTELSEIF(JJTELSEIF);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/ IfBlockStructure()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/           )*  

	
		  <ELSE>/*@bgen(jjtree) ELSE */
        {
          ASTELSE jjtn002 = new ASTELSE(JJTELSE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/ 
	( ElseBlockStructure() )/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/      
		
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void IfBlockStructure ()       : {Token t;}
{
	<LEFT_PAREN> BooleanExpression() <RIGHT_PAREN> <LEFT_BRACE> StatementList() <RIGHT_BRACE>
}
void ElseBlockStructure ()       : {Token t;}
{
	<LEFT_BRACE> StatementList() <RIGHT_BRACE>
}


void BooleanExpression ()        : {/*@bgen(jjtree) RelOp */
                                    ASTRelOp jjtn000 = new ASTRelOp(JJTRELOP);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) RelOp */
        try {
/*@egen*/
	Factor() 
	
	RelationalOp()
	  Factor()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	 //#RelOp(2)
}

void AssignmentStatement () : {/*@bgen(jjtree) AssignmentStatement */
  ASTAssignmentStatement jjtn000 = new ASTAssignmentStatement(JJTASSIGNMENTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentStatement */
        try {
/*@egen*/	
	Variable() {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
    }
    (listType())?
	<ASSIGNMENT>
	
	Expression() 
	(listType())?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}

void TypeSpecification ()       : {Token token;}
{
	<BOOLEAN_TYPE> | <URL_TYPE> | <DOMAIN_TYPE> | <INTEGER_TYPE> | <STRING_LIST_TYPE>  |<REAL_LIST_TYPE>  | <INTEGER_LIST_TYPE>  | <REAL_TYPE> | <STRING_TYPE>
}

void Variable ()           : {/*@bgen(jjtree) Variable */
  ASTVariable jjtn000 = new ASTVariable(JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Variable */
        try {
/*@egen*/
	<DOLLAR_SIGN> 
	<IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
        TypeSpec type = variableId.getTypeSpec();
        jjtn000.setTypeSpec(type);
        jjtn000.setAttribute(ID, variableId);
    }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
/*
void Function() #Func : {Token t;}
{
	< FUNCTION > t =<IDENTIFIER > //id = identifier 
	<LEFT_PAREN> 
	(TokenSpecification()(< COMMA > TokenSpecification())*) 
	<RIGHT_PAREN>	<LEFT_BRACE> StatementList() <RIGHT_BRACE>	  
}
*/
void Function ()      : {/*@bgen(jjtree) Func */
        ASTFunc jjtn000 = new ASTFunc(JJTFUNC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	// for declaration
	ArrayList<SymTabEntry> functionList;
	int index = 0;
	// for definition
	HashSet syncSet = new HashSet();
    syncSet.add(SEMICOLON);
    syncSet.add(EOF);
}
{/*@bgen(jjtree) Func */
        try {
/*@egen*/
	// function foo (Integer $x, Integer $y):void
	<FUNCTION> 
	<IDENTIFIER>{
		functionList = new ArrayList<SymTabEntry>();
		processFunctionDecl(token, index++, functionList);
		
		SymTabEntry typeId = symTabStack.lookup(token.image);
		System.out.println(token.image);
		typeId.appendLineNumber(token.beginLine);
		TypeSpec type = typeId.getTypeSpec();

		for (SymTabEntry functionId : functionList) {
			functionId.setTypeSpec(Predefined.funcType);
		}
		
		SymTabEntry functionId = symTabStack.lookup(token.image);
        functionId.appendLineNumber(token.beginLine);
        type = functionId.getTypeSpec();
        jjtn000.setTypeSpec(type);
        jjtn000.setAttribute(ID, functionId);
		
	}
	
	<LEFT_PAREN>FuncParams()<RIGHT_PAREN> <COLON> FuncReturnType()
	<LEFT_BRACE>
	StatementList()
	< RETURN > (Factor())?< SEMICOLON >
	<RIGHT_BRACE>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/

		{
        programId.setAttribute(ROUTINE_LOCALS_COUNT, index);
    }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void FuncCall()           : {/*@bgen(jjtree) FuncCall */
  ASTFuncCall jjtn000 = new ASTFuncCall(JJTFUNCCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FuncCall */
        try {
/*@egen*/ 
	FuncVar()/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  jjtn000.setTypeSpec(Predefined.funcCallType);
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void FuncVar()         :{/*@bgen(jjtree) FuncVar */
  ASTFuncVar jjtn000 = new ASTFuncVar(JJTFUNCVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FuncVar */
        try {
/*@egen*/
  	<IDENTIFIER> {
        SymTabEntry variableId = symTabStack.lookup(token.image);
        variableId.appendLineNumber(token.beginLine);
        TypeSpec type = variableId.getTypeSpec();
        jjtn000.setTypeSpec(type);
        jjtn000.setAttribute(ID, variableId);
    }
    <LEFT_PAREN>Factor()(< COMMA > Factor())*<RIGHT_PAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/}
  


void FuncParams()            :{/*@bgen(jjtree) FuncParams */
  ASTFuncParams jjtn000 = new ASTFuncParams(JJTFUNCPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FuncParams */
try {
/*@egen*/{int x;  x =1;
} (VariableDeclaration(x) (< COMMA >VariableDeclaration(x)) *)?/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void FuncReturnType()                :{/*@bgen(jjtree) FuncReturnType */
  ASTFuncReturnType jjtn000 = new ASTFuncReturnType(JJTFUNCRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FuncReturnType */
  try {
/*@egen*/
  (<VOID> | listItemType())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

/* new stuff! */

void Expression ()       : {}
{
	SimpleExpression() | listSize() | FuncCall()//( RelationalOp() SimpleExpression() )?
}


void SimpleExpression()       : {}
{
	(<PLUS> | <MINUS> )?
    Term() (
        <PLUS>/*@bgen(jjtree) #Add( 2) */
               {
                 ASTAdd jjtn001 = new ASTAdd(JJTADD);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/ Term()/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  2);
                 }
               }
/*@egen*/        
      | <MINUS>/*@bgen(jjtree) #Subtract( 2) */
                {
                  ASTSubtract jjtn002 = new ASTSubtract(JJTSUBTRACT);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/ Term()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  2);
                  }
                }
/*@egen*/             
    )*     
}

void Term ()       : {Token t;}
{
	Factor() (
			<STAR>/*@bgen(jjtree) #MultOp( 2) */
                               {
                                 ASTMultOp jjtn001 = new ASTMultOp(JJTMULTOP);
                                 boolean jjtc001 = true;
                                 jjtree.openNodeScope(jjtn001);
                               }
                               try {
/*@egen*/ Factor()/*@bgen(jjtree)*/
                               } catch (Throwable jjte001) {
                                 if (jjtc001) {
                                   jjtree.clearNodeScope(jjtn001);
                                   jjtc001 = false;
                                 } else {
                                   jjtree.popNode();
                                 }
                                 if (jjte001 instanceof RuntimeException) {
                                   throw (RuntimeException)jjte001;
                                 }
                                 if (jjte001 instanceof ParseException) {
                                   throw (ParseException)jjte001;
                                 }
                                 throw (Error)jjte001;
                               } finally {
                                 if (jjtc001) {
                                   jjtree.closeNodeScope(jjtn001,  2);
                                 }
                               }
/*@egen*/           
		|	<DIVIDE>/*@bgen(jjtree) #DivOp( 2) */
                                 {
                                   ASTDivOp jjtn002 = new ASTDivOp(JJTDIVOP);
                                   boolean jjtc002 = true;
                                   jjtree.openNodeScope(jjtn002);
                                 }
                                 try {
/*@egen*/ Factor()/*@bgen(jjtree)*/
                                 } catch (Throwable jjte002) {
                                   if (jjtc002) {
                                     jjtree.clearNodeScope(jjtn002);
                                     jjtc002 = false;
                                   } else {
                                     jjtree.popNode();
                                   }
                                   if (jjte002 instanceof RuntimeException) {
                                     throw (RuntimeException)jjte002;
                                   }
                                   if (jjte002 instanceof ParseException) {
                                     throw (ParseException)jjte002;
                                   }
                                   throw (Error)jjte002;
                                 } finally {
                                   if (jjtc002) {
                                     jjtree.closeNodeScope(jjtn002,  2);
                                   }
                                 }
/*@egen*/          
	)*
}

void Factor ()       : {}
{
	Variable() | 
	SimpleType() //| 
	/*( <LEFT_PAREN> Expression() <RIGHT_PAREN> ) | 
	MethodCall()*/
}

void SimpleType ()      : {Token t;}
{
		integerConstant() |
		realConstant() |
		stringConstant()
		/*
		t = <STRING> {jjtThis.setImage(t.image);} | 
		t = <URL> {jjtThis.setImage(t.image);} | 
		t = <DOMAIN> {jjtThis.setImage(t.image);} | 
		t = <BOOLEAN> {jjtThis.setImage(t.image);}
		*/
}


void RelationalOp () : {/*@bgen(jjtree) RelationalOp */
                        ASTRelationalOp jjtn000 = new ASTRelationalOp(JJTRELATIONALOP);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) RelationalOp */
        try {
/*@egen*/
	t = <EQUALS>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);}| 
	t = <NOT_EQUALS>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);} | 
	t = <LESS_EQUALS>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);} | 
	t = <GREATER_EQUALS>/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);} | 
	t = <LESS_THAN>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);} | 
	t = <GREATER_THAN>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.relType);
        jjtn000.setAttribute(VALUE, token.image);}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	
}
////////////////////////////////////////////////////////////////
void listSize()          : {/*@bgen(jjtree) ListSize */
                            ASTListSize jjtn000 = new ASTListSize(JJTLISTSIZE);
                            boolean jjtc000 = true;
                            jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}//D.M.
{/*@bgen(jjtree) ListSize */
  try {
/*@egen*/
  < OPBR >(integerConstant()|Variable())<CLBR >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  
}

void listItemType():{/*@bgen(jjtree) listItemType */
  ASTlistItemType jjtn000 = new ASTlistItemType(JJTLISTITEMTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) listItemType */
   try {
/*@egen*/
   <INTEGER_TYPE>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/{
        jjtn000.setTypeSpec(Predefined.integerType);
        jjtn000.setAttribute(VALUE, token.image);}
        | <STRING_TYPE>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/{
        jjtn000.setTypeSpec(Predefined.stringType);
        jjtn000.setAttribute(VALUE, token.image);
    }|
    < REAL_TYPE >/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/    {
      jjtn000.setTypeSpec(Predefined.realType);
        jjtn000.setAttribute(VALUE, token.image);    }|
        < URL_TYPE >/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.setTypeSpec(Predefined.urlType);
        jjtn000.setAttribute(VALUE, token.image);
    }|
       <INTEGER_LIST_TYPE>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/{
        jjtn000.setTypeSpec(Predefined.intListType);
        jjtn000.setAttribute(VALUE, token.image);}
        | <STRING_LIST_TYPE>/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/{
        jjtn000.setTypeSpec(Predefined.stringListType);
        jjtn000.setAttribute(VALUE, token.image);
    }|
    < REAL_LIST_TYPE >/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.setTypeSpec(Predefined.realListType);
        jjtn000.setAttribute(VALUE, token.image);
    }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
  
}
void listType()           : {/*@bgen(jjtree) ListIndex */
                             ASTListIndex jjtn000 = new ASTListIndex(JJTLISTINDEX);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}//D.M.
{/*@bgen(jjtree) ListIndex */
try {
/*@egen*/
< OPBR >(integerConstant()| Variable())<CLBR >/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
  
}

void integerConstant() : {/*@bgen(jjtree) integerConstant */
  ASTintegerConstant jjtn000 = new ASTintegerConstant(JJTINTEGERCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) integerConstant */
    try {
/*@egen*/
    <INTEGER>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.integerType);
        jjtn000.setAttribute(VALUE, Integer.parseInt(token.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void realConstant() : {/*@bgen(jjtree) realConstant */
  ASTrealConstant jjtn000 = new ASTrealConstant(JJTREALCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) realConstant */
    try {
/*@egen*/
    <REAL>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.realType);
        jjtn000.setAttribute(VALUE, Float.parseFloat(token.image));
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void stringConstant() : {/*@bgen(jjtree) stringConstant */
  ASTstringConstant jjtn000 = new ASTstringConstant(JJTSTRINGCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stringConstant */
    try {
/*@egen*/
    <STRING>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {
        jjtn000.setTypeSpec(Predefined.stringType);
        jjtn000.setAttribute(VALUE, token.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Error()       : {}
{
    <ERROR>
}



JAVACODE
/* Original version */
void processVariableDeclOrg(Token tokenoken, int index,
                         ArrayList<SymTabEntry> variableList)      
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
}

/* Based on PLC. Includes code from DM */
JAVACODE
void processVariableDecl_silva(Token tokenoken, SymTabStack symTabStack)      
{
	SymTabEntry variableId = symTabStack.lookupLocal(token.image);
	  						
	if (variableId != null) {
		variableId.appendLineNumber(token.beginLine);
	}

	else {
		variableId = symTabStack.enterLocal(token.image);
		variableId.appendLineNumber(token.beginLine);
		variableId.setDefinition(DefinitionImpl.VARIABLE);
		variableId.setAttribute(ROUTINE_SYMTAB, token.image);
	}
}

JAVACODE
void processVariableDecl(Token token, int index,
                         ArrayList<SymTabEntry> variableList)      
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
}

JAVACODE
void processFunctionDecl(Token token, int index,
                         ArrayList<SymTabEntry> funcList)      
{
    SymTabEntry funcId = symTabStack.enterLocal(token.image);
    funcId.setIndex(index);
    funcId.setDefinition(DefinitionImpl.FUNCTION);
    funcId.appendLineNumber(token.beginLine);
    funcList.add(funcId);
}

JAVACODE
String handleError(ParseException ex, HashSet syncSet, boolean doPop)      
{
    Token tokenoken = ex.currentToken;
    System.out.println(ex.getMessage());

    // Consume tokens up to but not including a token in the sync set.
    while (!syncSet.contains(getToken(1).kind)) {
        token = getNextToken();
    } 	

    if (doPop) jjtree.popNode();
    return token.image;
}
